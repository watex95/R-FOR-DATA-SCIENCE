counts <- table(mydata$loan_status)
gender=table(mydata$Gender)
barplot(counts,gender, main="loan_status by gender ",
xlab="principal", col=c("darkblue","red"),
legend = rownames(counts))
# Stacked Bar Plot with Colors and Legend
counts <- table(mydata$loan_status,mydata$Principal)
# Stacked Bar Plot with Colors and Legend
counts <- table(mydata$loan_status,mydata$Principal)
gender=table(mydata$Gender)
barplot(counts,gender, main="loan_status by gender ",
xlab="principal", col=c("darkblue","red"),
legend = rownames(counts))
attach(mydata)
mydata$due_date=as.Date(mydata$due_date,format = "%m/%d/%Y")
mydata$effective_date=as.Date(mydata$effective_date,format = "%m/%d/%Y")
gender=table(mydata$Gender=='male')
# Stacked Bar Plot with Colors and Legend
counts <- table(mydata$loan_status,mydata$Principal)
gender=table(mydata$Gender=='male')
barplot(counts,gender, main="loan_status by gender ",
xlab="principal", col=c("darkblue","red"),
legend = rownames(counts))
counts <- table(mydata$loan_status,mydata$Principal)
gender=table(mydata$Gender=='female')
barplot(counts,gender, main="loan_status by gender ",
xlab="principal", col=c("darkblue","red"),
legend = rownames(counts))
# Stacked Bar Plot with Colors and Legend
counts <- table(mydata$loan_status,mydata$Principal)
gender=table(mydata$Gender=='male')
barplot(counts,gender, main="loan_status by principal in males ",
xlab="principal", col=c("darkblue","red"),
legend = rownames(counts))
barplot(counts,gender, main="loan_status by principal in females ",
xlab="principal", col=c("darkblue","red"),
legend = rownames(counts))
counts <- table(mydata$loan_status,mydata$Principal)
gender=table(mydata$Gender=='female')
barplot(counts,gender, main="loan_status by principal in females ",
xlab="principal", col=c("darkblue","red"),
legend = rownames(counts))
counts <- table(mydata$loan_status,mydata$Principal)
gender=table(mydata$Gender=='female')
barplot(counts,gender, main="loan_status by principal in females ",
xlab="principal", col=c("darkblue","red"),
legend = rownames(counts))
gender=Gender=='female')
gender=mydata$Gender=='female')
gender=mydata$Gender=='female'
counts <- table(mydata$loan_status,mydata$Principal)
gender=mydata$Gender=='female'
barplot(counts,gender, main="loan_status by principal in females ",
xlab="principal", col=c("darkblue","red"),
legend = rownames(counts))
barplot(counts, main="loan_status by principal in females ",
xlab="principal", col=c("darkblue","red"),
legend = rownames(counts))
counts <- table(mydata$loan_status,mydata$Principal,exclude=if(mydata$Gender=='male') c('male','female'))
gender=mydata$Gender=='female'
barplot(counts, main="loan_status by principal in females ",
xlab="principal", col=c("darkblue","red"),
legend = rownames(counts))
counts <- table(mydata$loan_status,mydata$Principal,exclude=if(mydata$Gender=='female') c('male','female'))
counts <- table(mydata$loan_status,mydata$Principal,exclude=if(mydata$Gender=='female') c('female','male'))
gender=mydata$Gender=='female'
barplot(counts, main="loan_status by principal in females ",
xlab="principal", col=c("darkblue","red"),
legend = rownames(counts))
counts %>% group_by(Gender)
colnames(mydata)
counts <- table(mydata$loan_status,mydata$Principal,exclude=if(mydata$Gender=='female') c('female','male'))
counts %>% group_by(Gender)
counts <- table(mydata$loan_status,mydata$Principal,exclude=if(mydata$Gender=='female') c('female','male'))
barplot(counts, main="loan_status by principal in females ",
xlab="principal", col=c("darkblue","red"),
legend = rownames(counts))
counts <- table(mydata$loan_status,mydata$Principal,exclude=if(mydata$Gender=='female') )
str(mdata)
str(mydata)
as.factor(mydata[Gender,education,loan_status])
as.factor(mydata[Gender])
as.factor(mydata$Gender)
mydata$Gender=as.factor(mydata$Gender)
mydata$Gender=as.factor(mydata$Gender)
mydata$education=as.factor(mydata$education)
mydata$loan_status=as.factor(loan_status)
table(mydata$loan_status,mydata$education)
library(dummies)
# dummify the data
install.packages("dummies")
library(dummies)
mydata <- cbind(mydata, dummy(mydata$education))
head(mydata)
mydata <- cbind(education, dummy(mydata$education))
mydata <- cbind(education, dummy(mydata$education))
head(mydata)
mydata= cbind(mydata_, dummy(mydata$education))
mydata= cbind(mydata, dummy(mydata$education))
mydata
education.f = factor(education)
dummies = model.matrix(~education.f)
dummies
cbind(mydata,dummies)
mydata=cbind(mydata,dummies)
head(mydata)
mydata1= cbind(mydata, dummy(mydata$education))
#install.packages('data.table')
library(data.table)
mydata=fread('https://s3-api.us-geo.objectstorage.softlayer.net/cf-courses-data/CognitiveClass/ML0101ENv3/labs/loan_train.csv')
head(mydata)
dim(mydata)
attach(mydata)
mydata$due_date=as.Date(mydata$due_date,format = "%m/%d/%Y")
mydata$effective_date=as.Date(mydata$effective_date,format = "%m/%d/%Y")
table(mydata$loan_status)
# Stacked Bar Plot with Colors and Legend
counts <- table(mydata$loan_status,mydata$Principal)
gender=table(mydata$Gender=='male')
barplot(counts,gender, main="loan_status by principal in males ",
xlab="principal", col=c("darkblue","red"),
legend = rownames(counts))
counts <- table(mydata$loan_status,mydata$Principal,exclude=if(mydata$Gender=='female') c('female','male'))
barplot(counts, main="loan_status by principal in females ",
xlab="principal", col=c("darkblue","red"),
legend = rownames(counts))
colnames(mydata)
str(mydata)
mydata$Gender=as.factor(mydata$Gender)
mydata$education=as.factor(mydata$education)
mydata$loan_status=as.factor(loan_status)
table(mydata$loan_status,mydata$education)
# dummify the data
install.packages("dummies")
library(dummies)
mydata1= cbind(mydata, dummy(mydata$education))
# dummify the data
#install.packages("dummies")
library(dummies)
mydata1= cbind(mydata, dummy(mydata$education))
head(mydata1)
education.f = factor(education)
dummies = model.matrix(~education.f)
education.f = factor(education)
dummies = model.matrix(~education.f)
mydata2=cbind(mydata,dummies)
head(mydata2)
mydata1= cbind(mydata, dummy(education))
# dummify the data
#install.packages("dummies")
library(dummies)
mydata1= cbind(mydata, dummy(education))
head(mydata1)
# dummify the data
#install.packages("dummies")
library(dummies)
mydata1= cbind(mydata, dummy(education))
head(mydata1)
names(mydata1)[-1] <- sub("mydata", "", names(mydata1)[-1])
head(mydata1)
head(mydata1)
#Preparing mocking data
set.seed(123) #for reproducibility
# Here's how you substitute the values in just one line. This operation is vectorised.
mydata1$Gender <- ifelse(mydata1$Gender=='male', 1, ifelse(mydata1$Gender=='female',0, NA))
head(mydata1)
library(dplyr)
mydata2 <-mydata1
# Drop the columns of the dataframe
select (mydata2,c(Principal,terms,Gender,Bachelor,college,High School or Below,Master or Above))
library(dplyr)
mydata2 <-mydata1
# Drop the columns of the dataframe
select (mydata2,c(loan_status,effective_date,due_date,education))
library(dplyr)
mydata2 <-mydata1
# Drop the columns of the dataframe
select (mydata2,-c(loan_status,effective_date,due_date,education))
library(dplyr)
mydata2 <-mydata1
# Drop the columns of the dataframe
select (mydata2,-c(V1,Unnamed:0,loan_status,effective_date,due_date,education))
library(dplyr)
mydata2 <-mydata1
# Drop the columns of the dataframe
select (mydata2,-c(V1,Unnamed,loan_status,effective_date,due_date,education))
library(dplyr)
mydata2 <-mydata1
# Drop the columns of the dataframe
select (mydata2,-c(V1,loan_status,effective_date,due_date,education))
# Drop the columns of the dataframe
select (mydata2,-c(V1,mydata[,1],loan_status,effective_date,due_date,education))
library(dplyr)
mydata2 <-mydata1
# Drop the columns of the dataframe
select (mydata2,-c(V1,mydata2[,1],loan_status,effective_date,due_date,education))
# Drop the columns of the dataframe
select (mydata2,-c('V1',,'loan_status','effective_date','due_date,education'))
# Drop the columns of the dataframe
select (mydata2,-c('V1''loan_status','effective_date','due_date,education'))
library(dplyr)
mydata2 <-mydata1
# Drop the columns of the dataframe
select (mydata2,-c('V1','loan_status','effective_date','due_date,education'))
library(dplyr)
mydata2 <-mydata1
# Drop the columns of the dataframe
select (mydata2,-c('V1','loan_status','effective_date','due_date','education'))
# Drop the columns of the dataframe
select (mydata2,c('Principal','terms','age','Gender','Bachelor','college','High School','Master or Above'))
# Drop the columns of the dataframe
select (mydata2,c('Principal','terms','age','Gender','Bechalor','college','High School','Master or Above'))
# Drop the columns of the dataframe
select (mydata2,c('Principal','terms','age','Gender','Bechalor','college','High School or Below','Master or Above'))
head(X)
library(dplyr)
mydata2 <-mydata1
# Drop the columns of the dataframe
X=select (mydata2,c('Principal','terms','age','Gender','Bechalor','college','High School or Below','Master or Above'))
head(X)
library(dplyr)
mydata2 <-mydata1
# Drop the columns of the dataframe
X=select (mydata2,c('Principal','terms','age','Gender','Bechalor','college','High School or Below','Master or Above'))
head(X)
head(Y)
#Y variable
Y=mydata1$loan_status
head(Y)
dfNormZ <- as.data.frame( scale(X))
head(dfNormZ)
X <- as.data.frame( scale(X))
head(X)
dim(X)
mydata
library(dplyr)
mydata1=select (mydata1,c('loan_status','Principal','terms','age','Gender','Bechalor','college','High School or Below','Master or Above'))
head(mydata1)
# Random sample indexes
train_index <- sample(1:nrow(mydata1), 0.8 * nrow(mydata1))
test_index <- setdiff(1:nrow(mydata1), train_index)
# Build X_train, y_train, X_test, y_test
X_train <- mydata1[train_index, -3]
y_train <- mydata1[train_index, "loan_status"]
X_test <- mydata1[test_index, -3]
y_test <- mydata1[test_index, "loan_status"]
# Random sample indexes
train_index <- sample(1:nrow(mydata1), 0.8 * nrow(mydata1))
test_index <- setdiff(1:nrow(mydata1), train_index)
# Build X_train, y_train, X_test, y_test
X_train <- mydata1[train_index, -3]
y_train <- mydata1[train_index, "loan_status"]
X_test <- mydata1[test_index, -3]
y_test <- mydata1[test_index, "loan_status"]
X_train <- as.data.frame( scale(X_train))
# Random sample indexes
train_index <- sample(1:nrow(mydata1), 0.8 * nrow(mydata1))
test_index <- setdiff(1:nrow(mydata1), train_index)
# Build X_train, y_train, X_test, y_test
X_train <- mydata1[train_index, -1]
y_train <- mydata1[train_index, "loan_status"]
X_test <- mydata1[test_index, -1]
y_test <- mydata1[test_index, "loan_status"]
X_train <- as.data.frame( scale(X_train))
head(X_train)
X_test <- as.data.frame( scale(X_test))
X_test <- as.data.frame( scale(X_test))
head(X_test)
#To identify optimum value of k, generally square root of total no of observations (346) which is 26.45 is taken, so will try with 26, 27 then will check for optimal value of k.
knn.26 <-  knn(train=X_train, test=X_test, cl=y_train, k=18)
# load library
library(caret)
# load library
install.packages('caret')
# load library
install.packages('caret')
install.packages('e1071')
library(caret)
# load library
install.packages('caret')
install.packages('e1071')
library(caret)
install.packages("caret")
# load library
install.packages('caret')
install.packages('e1071')
library(caret)
# load library
install.packages('caret')
install.packages('e1071')
library(caret)
# load library
install.packages('caret')
install.packages('e1071')
library(caret)
install.packages('caret')
install.packages('e1071')
library(caret)
library(e1071)
#To identify optimum value of k, generally square root of total no of observations (346) which is 26.45 is taken, so will try with 26, 27 then will check for optimal value of k.
knn.26 <-  knn(train=X_train, test=X_test, cl=y_train, k=18)
#To identify optimum value of k, generally square root of total no of observations (346) which is 26.45 is taken, so will try with 26, 27 then will check for optimal value of k.
install.packages(“class”)
#To identify optimum value of k, generally square root of total no of observations (346) which is 26.45 is taken, so will try with 26, 27 then will check for optimal value of k.
install.packages('class')
library(class)
install.packages("class")
vec=c(34,1,23,4,3,3,12,4,3,1)
sd(vec)
library(e1071)
R.version()
R.version.string
UpdateR()
install.packages("instalr")
# installing/loading the package:
if(!require(installr)) {
install.packages("installr");
require(installr)
} #load / install+load installr
skewness(vec)
kurtosis(vec)
v1=c(1,2,3,4,5,6,7,8,9,10)
v2=c(7,6,5,4,5,6,7,8,9,10)
corr(v1,v2)
cor(v1,v2)
cov(v1,v2)
x=c(1,2,3,4,5,6,7)
y=c(7,6,5,4,5,6,7)
cor(x,y)
R -version
R.version
sparkR.session()
library(sparkR)
install.packages("sparkR")
library(SparkR)
install.packages("SparkR")
library(SparkR)
sparkR.session()
as.DataFrame(faithful)
df=as.DataFrame(faithful)
head(df)
sparkR.session(sparkPackages = "com.databricks:spark-avro_2.11:3.0.0")
people <- read.df("./examples/src/main/resources/people.json", "json")
install.packages("Sparklyr")
install.packages("sparklyr")
# CONNECT TO AN AZURE SQL DATABASE
library(RODBC)           # Provides database connectivity
library(nycflights13)    # SOme sample data
install.packages('nycflights13')
library(nycflights13)    # SOme sample data
library(dplyr)           # only used for nice format of Head() function here
# The Connection string comes from the Azure ODBC text box
connectionString <- "Driver={SQL Server Native Client 11.0};
Server=jdbc:sqlserver://hillaserver.database.windows.net,1433;
Database=myFirstDB;Uid=nyawate@hillaserver;Pwd={Glenda1998.};
Encrypt=yes;TrustServerCertificate=no;Connection Timeout=30;"
#Open your RODBC connection
myconn <- odbcDriverConnect(connectionString)
# CONNECT TO AN AZURE SQL DATABASE
library(RODBC)           # Provides database connectivity
library(nycflights13)    # SOme sample data
library(dplyr)           # only used for nice format of Head() function here
# The Connection string comes from the Azure ODBC text box
connectionString <-"Driver={ODBC Driver 13 for SQL Server};Server=tcp:hillaserver.database.windows.net,1433;
Database=myFirstDB;Uid=nyawate@hillaserver;Pwd={Glenda1998.};
Encrypt=yes;TrustServerCertificate=no;Connection Timeout=30;"
#Open your RODBC connection
myconn <- odbcDriverConnect(connectionString)
#Open your RODBC connection
myconn <- odbcDriverConnect(connectionString)
# The Connection string comes from the Azure ODBC text box
connectionString <-"Driver={ODBC Driver 17 for SQL Server};Server=tcp:hillaserver.database.windows.net,1433;
Database=myFirstDB;Uid=nyawate@hillaserver;Pwd={Glenda1998.};
Encrypt=yes;TrustServerCertificate=no;Connection Timeout=30;"
#Open your RODBC connection
myconn <- odbcDriverConnect(connectionString)
# The Connection string comes from the Azure ODBC text box
connectionString <-"Driver={ODBC Driver 17 for SQL Server};Server=tcp:hillaserver.database.windows.net,1433;
Database=myFirstDB;Uid=nyawate@hillaserver;Pwd={Glenda1998.};
Encrypt=yes;TrustServerCertificate=no;Connection Timeout=30;"
#Open your RODBC connection
myconn <- odbcDriverConnect(connectionString)
block_example <- list(index = 1,
timestamp = "2018-01-05 17.00 MST",
data = "some data",
previous_hash = 0,
proof = 9,
new_hash = NULL)
library("digest")
detach("package:digest", unload=TRUE)
library("digest", lib.loc="~/R/win-library/3.2")
detach("package:digest", unload=TRUE)
library("digest", lib.loc="~/R/win-library/3.2")
detach("package:digest", unload=TRUE)
install.packages("digest")
library("digest")
digest("Stata" ,"sha256") # first try
digest("R", "sha256") # second try
#Function that creates a hashed "block"
hash_block <- function(block){
block$new_hash <- digest(c(block$index,
block$timestamp,
block$data,
block$previous_hash), "sha256")
return(block)
}
### Simple Proof of Work Alogrithm
proof_of_work <- function(last_proof){
proof <- last_proof + 1
# Increment the proof number until a number is found that is divisable by 99 and by the proof of the previous block
while (!(proof %% 99 == 0 & proof %% last_proof == 0 )){
proof <- proof + 1
}
return(proof)
}
#A function that takes the previous block and normally some data (in our case the data is a string indicating which block in the chain it is)
gen_new_block <- function(previous_block){
#Proof-of-Work
new_proof <- proof_of_work(previous_block$proof)
#Create new Block
new_block <- list(index = previous_block$index + 1,
timestamp = Sys.time(),
data = paste0("this is block ", previous_block$index +1),
previous_hash = previous_block$new_hash,
proof = new_proof)
#Hash the new Block
new_block_hashed <- hash_block(new_block)
return(new_block_hashed)
}
# Define Genesis Block (index 1 and arbitrary previous hash)
block_genesis <-  list(index = 1,
timestamp = Sys.time(),
data = "Genesis Block",
previous_hash = "0",
proof = 1)
blockchain <- list(block_genesis)
previous_block <- blockchain[[1]]
# How many blocks should we add to the chain after the genesis block
num_of_blocks_to_add <- 5
# Add blocks to the chain
for (i in 1: num_of_blocks_to_add){
block_to_add <- gen_new_block(previous_block)
blockchain[i+1] <- list(block_to_add)
previous_block <- block_to_add
print(cat(paste0("Block ", block_to_add$index, " has been added", "\n",
"\t", "Proof: ", block_to_add$proof, "\n",
"\t", "Hash: ", block_to_add$new_hash)))
}
blockchain[[5]]
library('tm')
install.packages("tm")
getwd()
file <- 'KCSE.pdf'
Rpdf <- readPDF(control = list(text = "-layout"))
library(pdftools)
txt <- pdf_text("KCSE.pdf")
cat(txt[1])
install.packages("pdftools")
library(pdftools)
txt <- pdf_text("KCSE.pdf")
R.Version()
#installing/loading the package:
if(!require(installr)) {
install.packages("installr"); require(installr)} #load / install+load installr
# using the package:
updateR() # this will start the updating process of your R installation.  It will check for newer versions, and if one is available, will guide you through the decisions you'd need to make.
install.packages('devtools') #assuming it is not already installed
library(devtools)
install_github('andreacirilloac/updateR')
library(updateR)
install.packages("rjson")
# Load the package required to read JSON files.
library("rjson")
#Initialize the files
file1="pro_leave1.json"
file2="pro_leave2.json"
file3="pro_leave3.json"
file4="pro_remain.json"
file5="pro_remain2.json"
file6="pro_remain3.json"
result <- fromJSON(file = file5)
# Print the result.
print(result)
setwd("C:/Users/Administrator/Desktop/FREELANCER_COM_WORK/BREXIT analysis/extracted data")
result <- fromJSON(file = file5)
# Print the result.
print(result)
# # Convert JSON file to a data frame.
names=result$data$attributes$signatures_by_constituency
View(names)
## Compute maximum length
max.length <- max(sapply(names, length))
## Add NA values to list elements
names1 <- lapply(names, function(v) { c(v, rep(NA, max.length-length(v)))})
## Rbind
my_data=do.call(rbind, names1)
View(mydata)
View(my_data)
View(my_data)
View(mydata)
View(mydata)
View(mydata1)
my_data=as.data.frame(my_data)
my_data=my_data[,c("ons_code","signature_count")]
path2="C:/Users/Administrator/Desktop/FREELANCER_COM_WORK/BREXIT analysis/proleave2.txt"
path3="C:/Users/Administrator/Desktop/FREELANCER_COM_WORK/BREXIT analysis/proleave3.txt"
path4="C:/Users/Administrator/Desktop/FREELANCER_COM_WORK/BREXIT analysis/proremain1.txt"
path5="C:/Users/Administrator/Desktop/FREELANCER_COM_WORK/BREXIT analysis/proremain22.txt"
path6="C:/Users/Administrator/Desktop/FREELANCER_COM_WORK/BREXIT analysis/proremain3.txt"
library(data.table)
fwrite(x = my_data,
file = path5,sep = ",",col.names=T,append=T)
